#!/usr/bin/lua
-- Copyright Â© 2012 Zachary Catlin. See LICENSE for terms.

-- In the source tree, the source files for the packages we want to load
-- are in the same directory as this file; when installed onto a system,
-- they will probably be in a different directory altogether.
-- Accordingly, the installation script will modify the following line:
package.path = string.gsub(arg[0], '[^/\\]*$', '') .. '?.lua'

local argc, i = table.maxn(arg), 1
local input, output
local showDebugInfo = false

-- Options processing
while i <= argc do
  if arg[i] == '-o' then
    if output ~= nil then
      io.stderr:write(arg[0] .. ': Error: Multiple output files specified\n')
      os.exit(1)
    end

    i = i + 1
    output = arg[i]
  elseif arg[i] == '-d' then
    showDebugInfo = true
  else
    if input ~= nil then
      io.stderr:write(arg[0] .. ': Error: Multiple input files specified\n')
      os.exit(1)
    end

    input = arg[i]
  end

  i = i + 1
end

--print('input = ' .. tostring(input))
--print('output = ' .. tostring(output))

local fin = io.stdin

if input ~= nil then
  local errMsg
  fin, errMsg = io.open(input, 'r')
  if fin == nil then
    io.stderr:write(arg[0] .. ': Error : ' .. tostring(errMsg) .. '\n')
    os.exit(1)
  end
end

require('limeparse')
require('limeutil')
require('limefa')
require('limegen')

local ok, x = pcall(limeparse.readFile, fin)
if not ok then
  io.stderr:write(arg[0] .. ': Parsing error: ' .. tostring(x) .. '\n')
  os.exit(1)
end
fin:close()

if showDebugInfo then
  print(x)
  print('initState = ' .. tostring(x.initState))
  print('states = {')
  for k,v in pairs(x.states) do
    print('', k)
  end
  print('}')
  print('header = {' .. x.header .. '}\n')
  for i = 1,table.maxn(x.tokens) do
    print('startStates[' .. i .. ']: {')
    for k,v in pairs(x.tokens[i][3]) do
      print('  ', k)
    end
    print('}')
    print('regexp[' .. i .. ']:')
    limeutil.printRegex(io.stdout, x.tokens[i][1])
    print('optimizedRegexp[' .. i .. ']:')
    limeutil.printRegex(io.stdout, x.tokens[i][1]:optimize())
    print('partialNFA[' .. i .. ']:')
    limefa.printFA(io.stdout, limefa.regexCompile({x.tokens[i][1]}))
    print('code[' .. i .. ']:\n', x.tokens[i][2])
  end
end

local regexes = {}
for i = 1,table.maxn(x.tokens) do
  table.insert(regexes, x.tokens[i][1])
end
local nfa = limefa.regexCompile(regexes)

if showDebugInfo then
  print('totalNFA:')
  limefa.printFA(io.stdout, nfa)
end

local dfa = limefa.NFAtoDFA(nfa)

if showDebugInfo then
  print('totalDFA:')
  limefa.printFA(io.stdout, dfa)
end

local fout = io.stdout
if output ~= nil then
  local errMsg
  fout, errMsg = io.open(output, 'w')
  if fout == nil then
    io.stderr:write(arg[0] .. ': Error: ' .. errMsg)
    os.exit(1)
  end
end
limegen.write(x, dfa, fout)
fout:close()
